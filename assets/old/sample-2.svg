<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     version="1.1" baseProfile="full"
     viewBox="0 0 800 1500"
     preserveAspectRatio="xMidYMid meet"
     width="800" height="1500">

  <!-- 高度なフィルター定義 -->
  <defs>
    <!-- 量子場効果フィルター -->
    <filter id="quantumField" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="5" seed="3" stitchTiles="stitch" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="20" xChannelSelector="R" yChannelSelector="G"/>
      <feGaussianBlur stdDeviation="1.5" result="blur"/>
      <feBlend in="SourceGraphic" in2="blur" mode="multiply"/>
    </filter>
    
    <!-- 光の屈折フィルター -->
    <filter id="lightRefraction" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence type="turbulence" baseFrequency="0.05" numOctaves="2" seed="5" result="turbulence"/>
      <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="10" xChannelSelector="R" yChannelSelector="G"/>
      <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.7 0" result="colored"/>
      <feComposite in="SourceGraphic" in2="colored" operator="arithmetic" k1="0.5" k2="0.5" k3="0.5" k4="0"/>
    </filter>
    
    <!-- 深度マップフィルター -->
    <filter id="depthMap" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="3" seed="2" result="noise"/>
      <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.5 0" result="darkness"/>
      <feGaussianBlur in="darkness" stdDeviation="2" result="blur"/>
      <feBlend in="SourceGraphic" in2="blur" mode="multiply"/>
    </filter>
    
    <!-- 次元間干渉フィルター -->
    <filter id="dimensionalInterference" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence type="turbulence" baseFrequency="0.03 0.05" numOctaves="4" seed="10" result="turbulence"/>
      <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="15" xChannelSelector="R" yChannelSelector="G"/>
      <feColorMatrix type="hueRotate" values="90" result="hueShift"/>
      <feBlend in="SourceGraphic" in2="hueShift" mode="screen"/>
    </filter>
    
    <!-- 強化した3D深度フィルター -->
    <filter id="enhanced3dDepth" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence type="fractalNoise" baseFrequency="0.007" numOctaves="5" seed="7" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="30" xChannelSelector="R" yChannelSelector="G" result="displace"/>
      <feGaussianBlur in="displace" stdDeviation="2" result="blur"/>
      <feSpecularLighting in="blur" surfaceScale="3" specularConstant="1.5" specularExponent="20" lighting-color="#ffffff" result="specular">
        <fePointLight x="250" y="250" z="100"/>
      </feSpecularLighting>
      <feComposite in="SourceGraphic" in2="specular" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" result="composite"/>
      <feBlend in="composite" in2="blur" mode="multiply"/>
    </filter>
    
    <!-- 立体的なテクスチャフィルター -->
    <filter id="3dTexture" x="-50%" y="-50%" width="200%" height="200%">
      <feTurbulence type="turbulence" baseFrequency="0.05" numOctaves="3" seed="15" result="turbulence"/>
      <feDiffuseLighting in="turbulence" surfaceScale="5" diffuseConstant="1" result="diffuse">
        <feDistantLight azimuth="45" elevation="60"/>
      </feDiffuseLighting>
      <feComposite in="SourceGraphic" in2="diffuse" operator="arithmetic" k1="1" k2="0" k3="0.5" k4="0"/>
    </filter>
    
    <!-- 流体力学シミュレーションのためのグラデーション -->
    <linearGradient id="fluidGradient1" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#0f2350" stop-opacity="0.8"/>
      <stop offset="25%" stop-color="#1e3a8a" stop-opacity="0.9"/>
      <stop offset="50%" stop-color="#2563eb" stop-opacity="0.95"/>
      <stop offset="75%" stop-color="#1e40af" stop-opacity="0.9"/>
      <stop offset="100%" stop-color="#172554" stop-opacity="0.8"/>
    </linearGradient>
    
    <linearGradient id="fluidGradient2" x1="100%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#0c4a6e" stop-opacity="0.7"/>
      <stop offset="30%" stop-color="#0369a1" stop-opacity="0.8"/>
      <stop offset="70%" stop-color="#0284c7" stop-opacity="0.8"/>
      <stop offset="100%" stop-color="#075985" stop-opacity="0.7"/>
    </linearGradient>
    
    <linearGradient id="fluidGradient3" x1="50%" y1="0%" x2="50%" y2="100%">
      <stop offset="0%" stop-color="#312e81" stop-opacity="0.6"/>
      <stop offset="40%" stop-color="#4338ca" stop-opacity="0.7"/>
      <stop offset="60%" stop-color="#4f46e5" stop-opacity="0.7"/>
      <stop offset="100%" stop-color="#3730a3" stop-opacity="0.6"/>
    </linearGradient>
    
    <!-- 量子パーティクルのためのフィルター -->
    <filter id="quantumParticle" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2" result="blur"/>
      <feColorMatrix type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 15 -2" result="glow"/>
      <feBlend in="SourceGraphic" in2="glow" mode="screen"/>
    </filter>
    
    <!-- 波動関数の干渉パターン用マスク -->
    <mask id="waveMask">
      <rect width="100%" height="100%" fill="#ff42b0"/>
      <rect width="100%" height="100%" fill="url(#wavePattern)" opacity="0.3"/>
    </mask>
    
    <pattern id="wavePattern" patternUnits="userSpaceOnUse" width="200" height="200" patternTransform="scale(0.5)">
      <path d="M0,100 C20,140 50,60 70,100 S100,140 150,100 S180,60 200,100" fill="none" stroke="black" stroke-width="5"/>
      <path d="M0,50 C30,90 60,10 90,50 S120,90 150,50 S180,10 200,50" fill="none" stroke="black" stroke-width="5" transform="translate(0,20)"/>
      <path d="M0,150 C30,190 60,110 90,150 S120,190 150,150 S180,110 200,150" fill="none" stroke="black" stroke-width="5" transform="translate(10,-20)"/>
    </pattern>
  </defs>

  <style type="text/css"><![CDATA[
    /* ベースのスタイル定義 */
    @keyframes bgScroll {
      from { background-position: 0 0; }
      to { background-position: -800px 0; }
    }
    
    svg {
      background: #0a1128;
    }
    
    body {
      margin: 0;
      padding: 16px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',
                   Roboto, Oxygen, Ubuntu, Cantarell,
                   'Open Sans', 'Helvetica Neue', sans-serif;
      color: #fff;
      background: transparent;
    }
    
    h1, h2, h3 { margin: 20px 0 12px 0; }
    h2 {
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      margin-top: 30px;
    }
    ul { margin: 0 0 24px 20px; padding: 0; }
    p { margin: 12px 0 24px 0; }
    img { max-width: 100%; height: auto; vertical-align: middle; }
    a { color: inherit; text-decoration: none; }
    .center { text-align: center; }
    .flex-center { 
      display: flex; 
      align-items: center; 
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 24px;
    }
    .badge-row { 
      margin: 16px 0 24px 0;
    }
    .badge-row img { 
      margin: 4px; 
    }
    .stats-card {
      height: 170px !important;
      width: auto;
    }
    .stats-section {
      margin-bottom: 30px;
    }
    
    /* アニメーション定義 */
    @keyframes fluidMove1 {
      0% { transform: translate(0, 0) scale(1.05); opacity: 0.7; }
      25% { transform: translate(-20px, 10px) scale(1); opacity: 0.9; }
      50% { transform: translate(-10px, -15px) scale(0.95); opacity: 0.8; }
      75% { transform: translate(15px, -5px) scale(1.02); opacity: 0.7; }
      100% { transform: translate(0, 0) scale(1.05); opacity: 0.7; }
    }
    
    @keyframes fluidMove2 {
      0% { transform: translate(0, 0) scale(1); opacity: 0.6; }
      33% { transform: translate(15px, -10px) scale(1.05); opacity: 0.8; }
      66% { transform: translate(-15px, 5px) scale(0.98); opacity: 0.7; }
      100% { transform: translate(0, 0) scale(1); opacity: 0.6; }
    }
    
    @keyframes fluidMove3 {
      0% { transform: translate(0, 0) rotate(0deg) scale(1.02); opacity: 0.5; }
      20% { transform: translate(-5px, 10px) rotate(1deg) scale(1); opacity: 0.7; }
      40% { transform: translate(-15px, -5px) rotate(-1deg) scale(0.98); opacity: 0.6; }
      60% { transform: translate(10px, -15px) rotate(-2deg) scale(1.03); opacity: 0.7; }
      80% { transform: translate(5px, 5px) rotate(1deg) scale(1.01); opacity: 0.6; }
      100% { transform: translate(0, 0) rotate(0deg) scale(1.02); opacity: 0.5; }
    }
    
    @keyframes particleFloat {
      0%, 100% { transform: translate(0, 0); opacity: 0.8; }
      25% { transform: translate(var(--tx1, 10px), var(--ty1, -10px)); opacity: 0.9; }
      50% { transform: translate(var(--tx2, 15px), var(--ty2, 5px)); opacity: 1; }
      75% { transform: translate(var(--tx3, 5px), var(--ty3, 15px)); opacity: 0.9; }
    }
    
    @keyframes dimensionShift {
      0% { filter: hue-rotate(0deg) blur(0px); transform: scale(1) rotate(0deg); }
      25% { filter: hue-rotate(90deg) blur(1px); transform: scale(1.05) rotate(1deg); }
      50% { filter: hue-rotate(180deg) blur(0px); transform: scale(0.98) rotate(-1deg); }
      75% { filter: hue-rotate(270deg) blur(1px); transform: scale(1.02) rotate(0.5deg); }
      100% { filter: hue-rotate(360deg) blur(0px); transform: scale(1) rotate(0deg); }
    }
    
    @keyframes quantumFluctuation {
      0%, 100% { opacity: 0.1; }
      50% { opacity: 0.3; }
    }
    
    @keyframes waveMotion {
      0% { transform: translateY(0) scaleY(1); }
      50% { transform: translateY(-5px) scaleY(1.05); }
      100% { transform: translateY(0) scaleY(1); }
    }
    
    @keyframes depthPulse {
      0%, 100% { filter: brightness(1) contrast(1); }
      50% { filter: brightness(1.2) contrast(1.1); }
    }
    
    @keyframes colorShift {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    
    /* 強化された3Dアニメーション */
    @keyframes enhanced3dFloat {
      0% { transform: translate3d(0, 0, 0) rotateX(0deg) rotateY(0deg); }
      25% { transform: translate3d(var(--tx1, 15px), var(--ty1, -15px), 50px) rotateX(5deg) rotateY(3deg); }
      50% { transform: translate3d(var(--tx2, 20px), var(--ty2, 10px), -30px) rotateX(-2deg) rotateY(5deg); }
      75% { transform: translate3d(var(--tx3, 0px), var(--ty3, 20px), 20px) rotateX(4deg) rotateY(-2deg); }
      100% { transform: translate3d(0, 0, 0) rotateX(0deg) rotateY(0deg); }
    }
    
    @keyframes parallaxShift {
      0% { transform: translate3d(0, 0, 0); }
      25% { transform: translate3d(var(--shift-x, -10px), var(--shift-y, 5px), var(--shift-z, 0)); }
      50% { transform: translate3d(calc(var(--shift-x, -10px) * -0.5), calc(var(--shift-y, 5px) * -1), calc(var(--shift-z, 0) * -1)); }
      75% { transform: translate3d(calc(var(--shift-x, -10px) * 0.7), calc(var(--shift-y, 5px) * 0.3), calc(var(--shift-z, 0) * 0.5)); }
      100% { transform: translate3d(0, 0, 0); }
    }
    
    @keyframes depthRotation {
      0% { transform: perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0); }
      25% { transform: perspective(1000px) rotateX(5deg) rotateY(3deg) translateZ(50px); }
      50% { transform: perspective(1000px) rotateX(-3deg) rotateY(-5deg) translateZ(-20px); }
      75% { transform: perspective(1000px) rotateX(-5deg) rotateY(2deg) translateZ(20px); }
      100% { transform: perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0); }
    }
    
    /* 3D変換とパースペクティブ */
    .perspective-container {
      transform-style: preserve-3d;
      perspective: 2000px;
      transform: translateZ(0);
      backface-visibility: hidden;
      position: relative;
      overflow: hidden;
    }
    
    .parallax-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      will-change: transform;
    }
    
    .parallax-layer-1 {
      animation: parallaxShift 25s ease-in-out infinite;
      --shift-x: -20px;
      --shift-y: 10px;
      --shift-z: 50px;
    }
    
    .parallax-layer-2 {
      animation: parallaxShift 20s ease-in-out infinite;
      --shift-x: 15px;
      --shift-y: -15px;
      --shift-z: -20px;
    }
    
    .parallax-layer-3 {
      animation: parallaxShift 30s ease-in-out infinite;
      --shift-x: -10px;
      --shift-y: -20px;
      --shift-z: 30px;
    }
    
    .fluid-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      mix-blend-mode: screen;
      transform-style: preserve-3d;
      will-change: transform;
    }
    
    .fluid-layer-1 {
      animation: fluidMove1 20s ease-in-out infinite, colorShift 25s linear infinite, depthRotation 35s ease-in-out infinite;
      transform: translateZ(30px);
    }
    
    .fluid-layer-2 {
      animation: fluidMove2 25s ease-in-out infinite, colorShift 35s linear infinite reverse, depthRotation 40s ease-in-out infinite reverse;
      transform: translateZ(0px);
    }
    
    .fluid-layer-3 {
      animation: fluidMove3 22s ease-in-out infinite, colorShift 30s linear infinite, depthRotation 45s ease-in-out infinite;
      transform: translateZ(-30px);
    }
    
    .quantum-particle {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
      mix-blend-mode: screen;
      filter: url(#quantumParticle);
      animation: enhanced3dFloat 15s ease-in-out infinite;
      transform-origin: center center;
      will-change: transform;
    }
    
    .enhanced-particle {
      box-shadow: 0 0 15px rgba(100, 200, 255, 0.8);
      filter: url(#enhanced3dDepth);
    }
    
    .wave-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      animation: waveMotion 8s ease-in-out infinite, depthRotation 30s ease-in-out infinite;
      opacity: 0.2;
      transform-style: preserve-3d;
    }
    
    .dimension-portal {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(65,105,225,0.7) 0%, rgba(65,105,225,0) 70%);
      mix-blend-mode: screen;
      animation: dimensionShift 20s linear infinite, depthRotation 40s ease-in-out infinite;
      filter: url(#dimensionalInterference);
      transform-style: preserve-3d;
      will-change: transform;
    }
    
    .quantum-field {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url(#quantumField);
      opacity: 0.1;
      animation: quantumFluctuation 10s ease-in-out infinite;
    }
    
    .depth-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      animation: depthPulse 15s ease-in-out infinite;
      transform-style: preserve-3d;
    }
    
    .foreground-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      transform: translateZ(100px);
      will-change: transform;
      pointer-events: none;
    }
    
    .midground-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      transform: translateZ(0);
      will-change: transform;
      pointer-events: none;
    }
    
    .background-layer {
      position: absolute;
      width: 100%;
      height: 100%;
      transform: translateZ(-100px);
      will-change: transform;
      pointer-events: none;
    }
    
    /* 3D立体形状 */
    .shape3d {
      position: absolute;
      transform-style: preserve-3d;
      animation: depthRotation 30s ease-in-out infinite;
      opacity: 0.15;
      mix-blend-mode: screen;
    }
    
    .cube3d {
      width: 100px;
      height: 100px;
    }
    
    .cube-face {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(100, 150, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .cube-front {
      transform: translateZ(50px);
    }
    
    .cube-back {
      transform: rotateY(180deg) translateZ(50px);
    }
    
    .cube-left {
      transform: rotateY(-90deg) translateZ(50px);
    }
    
    .cube-right {
      transform: rotateY(90deg) translateZ(50px);
    }
    
    .cube-top {
      transform: rotateX(90deg) translateZ(50px);
    }
    
    .cube-bottom {
      transform: rotateX(-90deg) translateZ(50px);
    }
  ]]></style>

  <!-- 背景レイヤー -->
  <rect width="100%" height="100%" fill="#0a1128"/>
  
  <!-- 量子場効果レイヤー -->
  <rect class="quantum-field" width="100%" height="100%" fill="url(#fluidGradient1)" opacity="0.05" filter="url(#quantumField)"/>
  
  <!-- 深度レイヤー -->
  <g class="depth-layer" filter="url(#depthMap)">
    <rect width="100%" height="100%" fill="url(#fluidGradient2)" opacity="0.1"/>
  </g>
  
  <!-- パララックス背景レイヤー -->
  <g class="parallax-layer parallax-layer-3 background-layer">
    <rect width="100%" height="100%" fill="#050a18" opacity="0.3" filter="url(#3dTexture)"/>
  </g>
  
  <!-- 流体力学シミュレーションレイヤー -->
  <g class="perspective-container">
    <!-- 背景流体レイヤー -->
    <path class="fluid-layer fluid-layer-3" d="M0,500 C200,450 300,550 500,500 S700,450 900,500 S1100,550 1300,500 V800 H0 Z" fill="url(#fluidGradient3)" opacity="0.4" filter="url(#lightRefraction)"/>
    
    <!-- 中間流体レイヤー -->
    <path class="fluid-layer fluid-layer-2" d="M0,400 C150,350 250,450 400,400 S550,350 700,400 S850,450 1000,400 V700 H0 Z" fill="url(#fluidGradient2)" opacity="0.5" filter="url(#lightRefraction)"/>
    
    <!-- 前景流体レイヤー -->
    <path class="fluid-layer fluid-layer-1" d="M0,300 C100,250 200,350 300,300 S400,250 500,300 S600,350 700,300 S800,250 900,300 V600 H0 Z" fill="url(#fluidGradient1)" opacity="0.6" filter="url(#enhanced3dDepth)"/>
    
    <!-- 3Dキューブオブジェクト -->
    <g class="shape3d cube3d" style="left: 150px; top: 250px;">
      <rect class="cube-face cube-front" fill="rgba(65, 105, 225, 0.3)"/>
      <rect class="cube-face cube-back" fill="rgba(65, 105, 225, 0.2)"/>
      <rect class="cube-face cube-left" fill="rgba(30, 64, 175, 0.25)"/>
      <rect class="cube-face cube-right" fill="rgba(30, 64, 175, 0.25)"/>
      <rect class="cube-face cube-top" fill="rgba(100, 150, 255, 0.3)"/>
      <rect class="cube-face cube-bottom" fill="rgba(20, 40, 130, 0.2)"/>
    </g>
    
    <g class="shape3d cube3d" style="left: 600px; top: 500px;">
      <rect class="cube-face cube-front" fill="rgba(100, 70, 200, 0.3)"/>
      <rect class="cube-face cube-back" fill="rgba(100, 70, 200, 0.2)"/>
      <rect class="cube-face cube-left" fill="rgba(80, 40, 180, 0.25)"/>
      <rect class="cube-face cube-right" fill="rgba(80, 40, 180, 0.25)"/>
      <rect class="cube-face cube-top" fill="rgba(130, 100, 220, 0.3)"/>
      <rect class="cube-face cube-bottom" fill="rgba(60, 20, 150, 0.2)"/>
    </g>
  </g>
  
  <!-- パララックス中間レイヤー -->
  <g class="parallax-layer parallax-layer-2 midground-layer">
    <!-- 波動関数の干渉パターン -->
    <g class="wave-container" mask="url(#waveMask)">
      <rect width="100%" height="100%" fill="#4338ca" opacity="0.15" filter="url(#3dTexture)"/>
    </g>
  </g>
  
  <!-- 量子パーティクル -->
  <circle class="quantum-particle enhanced-particle" cx="200" cy="300" r="5" style="--tx1: 30px; --ty1: -20px; --tx2: 50px; --ty2: 10px; --tx3: 20px; --ty3: 40px;"/>
  <circle class="quantum-particle enhanced-particle" cx="600" cy="200" r="8" style="--tx1: -40px; --ty1: -30px; --tx2: -20px; --ty2: 20px; --tx3: -50px; --ty3: 30px;"/>
  <circle class="quantum-particle enhanced-particle" cx="400" cy="500" r="6" style="--tx1: 20px; --ty1: 40px; --tx2: -30px; --ty2: 20px; --tx3: -10px; --ty3: -30px;"/>
  <circle class="quantum-particle enhanced-particle" cx="700" cy="600" r="4" style="--tx1: -20px; --ty1: 30px; --tx2: -40px; --ty2: -10px; --tx3: -10px; --ty3: 20px;"/>
  <circle class="quantum-particle enhanced-particle" cx="300" cy="800" r="7" style="--tx1: 40px; --ty1: 20px; --tx2: 10px; --ty2: -30px; --tx3: 30px; --ty3: -10px;"/>
  <circle class="quantum-particle enhanced-particle" cx="500" cy="1000" r="5" style="--tx1: -30px; --ty1: -20px; --tx2: 20px; --ty2: -40px; --tx3: 40px; --ty3: 10px;"/>
  <circle class="quantum-particle enhanced-particle" cx="200" cy="1200" r="6" style="--tx1: 20px; --ty1: -40px; --tx2: 40px; --ty2: 10px; --tx3: 10px; --ty3: 30px;"/>
  <circle class="quantum-particle enhanced-particle" cx="600" cy="1400" r="8" style="--tx1: -40px; --ty1: 10px; --tx2: -10px; --ty2: 30px; --tx3: -30px; --ty3: -20px;"/>
  
  <!-- パララックス前景レイヤー -->
  <g class="parallax-layer parallax-layer-1 foreground-layer">
    <!-- 次元間干渉ポータル -->
    <circle class="dimension-portal" cx="150" cy="400" r="100" opacity="0.2" filter="url(#enhanced3dDepth)"/>
    <circle class="dimension-portal" cx="650" cy="300" r="80" opacity="0.15" filter="url(#enhanced3dDepth)"/>
    <circle class="dimension-portal" cx="400" cy="700" r="120" opacity="0.1" filter="url(#enhanced3dDepth)"/>
    <circle class="dimension-portal" cx="700" cy="900" r="90" opacity="0.2" filter="url(#enhanced3dDepth)"/>
    <circle class="dimension-portal" cx="200" cy="1100" r="110" opacity="0.15" filter="url(#enhanced3dDepth)"/>
    <circle class="dimension-portal" cx="600" cy="1300" r="100" opacity="0.1" filter="url(#enhanced3dDepth)"/>
  </g>

  <!-- 高度なJavaScriptアニメーション -->
  <script type="text/javascript"><![CDATA[
    (function() {
      // requestAnimationFrameのポリフィル
      const requestAnimFrame = window.requestAnimationFrame || 
                              window.webkitRequestAnimationFrame || 
                              window.mozRequestAnimationFrame || 
                              function(callback) { window.setTimeout(callback, 1000/60); };
      
      // マウスポジショントラッキング
      let mouseX = 0;
      let mouseY = 0;
      let windowWidth = window.innerWidth || document.documentElement.clientWidth;
      let windowHeight = window.innerHeight || document.documentElement.clientHeight;
      
      // マウス移動イベントリスナー
      document.addEventListener('mousemove', function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        updateParallaxEffect();
      });
      
      // リサイズイベントリスナー
      window.addEventListener('resize', function() {
        windowWidth = window.innerWidth || document.documentElement.clientWidth;
        windowHeight = window.innerHeight || document.documentElement.clientHeight;
      });
      
      // パララックス効果の更新
      function updateParallaxEffect() {
        const parallaxLayers = document.querySelectorAll('.parallax-layer');
        
        // マウス位置を正規化（-1 から 1 の範囲）
        const normalizedX = (mouseX / windowWidth) * 2 - 1;
        const normalizedY = (mouseY / windowHeight) * 2 - 1;
        
        parallaxLayers.forEach((layer, index) => {
          // 各レイヤーに異なる強度のパララックス効果を適用
          const depthFactor = 0.05 * (index + 1);
          const moveX = normalizedX * 50 * depthFactor;
          const moveY = normalizedY * 50 * depthFactor;
          
          // 3D変換を適用
          layer.style.transform = `translate3d(${moveX}px, ${moveY}px, 0)`;
        });
        
        // 3Dキューブと量子パーティクルのマウス追従回転
        const shapes = document.querySelectorAll('.shape3d');
        shapes.forEach((shape) => {
          shape.style.transform = `rotateY(${normalizedX * 20}deg) rotateX(${normalizedY * -20}deg)`;
        });
        
        // 量子パーティクルも若干マウスに反応させる
        const particles = document.querySelectorAll('.quantum-particle');
        particles.forEach((particle) => {
          const randomOffset = Math.random() * 5;
          particle.style.transform = `translate3d(${normalizedX * 10 + randomOffset}px, ${normalizedY * 10 + randomOffset}px, 0)`;
        });
      }
      
      // キャンバス作成関数
      function createCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '-1';
        canvas.style.opacity = '0.3';
        canvas.style.mixBlendMode = 'screen';
        document.querySelector('body').appendChild(canvas);
        return canvas;
      }
      
      // 流体シミュレーション
      class FluidSimulation {
        constructor(width, height) {
          this.canvas = createCanvas(width, height);
          this.ctx = this.canvas.getContext('2d');
          this.width = width;
          this.height = height;
          this.particles = [];
          this.flowField = [];
          this.mouseInfluence = { x: 0, y: 0, active: false, strength: 100 };
          this.init();
          
          // マウス影響のイベントリスナー
          document.addEventListener('mousemove', this.handleMouseMove.bind(this));
          document.addEventListener('mousedown', () => { this.mouseInfluence.active = true; });
          document.addEventListener('mouseup', () => { this.mouseInfluence.active = false; });
        }
        
        handleMouseMove(e) {
          // キャンバス内の相対座標に変換
          const rect = this.canvas.getBoundingClientRect();
          this.mouseInfluence.x = (e.clientX - rect.left) * (this.width / rect.width);
          this.mouseInfluence.y = (e.clientY - rect.top) * (this.height / rect.height);
        }
        
        init() {
          // 流体場の初期化 - より細かく
          for (let y = 0; y < this.height; y += 15) {
            for (let x = 0; x < this.width; x += 15) {
              this.flowField.push({
                x: x,
                y: y,
                angle: Math.random() * Math.PI * 2,
                strength: Math.random() * 0.5 + 0.1,
                z: Math.random() * 200 - 100 // Z座標を追加
              });
            }
          }
          
          // パーティクルの初期化 - より多く、3D属性を追加
          for (let i = 0; i < 150; i++) {
            this.particles.push({
              x: Math.random() * this.width,
              y: Math.random() * this.height,
              z: Math.random() * 200 - 100, // Z座標（奥行き）
              size: Math.random() * 3 + 1,
              speedX: 0,
              speedY: 0,
              speedZ: 0, // Z方向の速度
              color: `hsla(${Math.random() * 60 + 200}, 100%, 70%, 0.3)`
            });
          }
          
          this.animate();
        }
        
        // 最も近い流体場のインデックスを取得
        getClosestFlowField(x, y, z) {
          let closestIndex = 0;
          let closestDist = Number.MAX_VALUE;
          
          for (let i = 0; i < this.flowField.length; i++) {
            const field = this.flowField[i];
            const dx = field.x - x;
            const dy = field.y - y;
            const dz = field.z - z;
            const dist = dx * dx + dy * dy + dz * dz; // 3D距離
            
            if (dist < closestDist) {
              closestDist = dist;
              closestIndex = i;
            }
          }
          
          return this.flowField[closestIndex];
        }
        
        // パーティクルの更新
        updateParticles() {
          for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            
            // 最も近い流体場を取得
            const field = this.getClosestFlowField(p.x, p.y, p.z);
            
            // 流体場に基づいて速度を更新
            p.speedX += Math.cos(field.angle) * field.strength;
            p.speedY += Math.sin(field.angle) * field.strength;
            p.speedZ += (Math.sin(field.angle + Math.PI/4) * field.strength) * 0.3; // Z方向の動きを追加
            
            // マウスの影響（3D空間での吸引または反発）
            if (this.mouseInfluence.active) {
              const dx = this.mouseInfluence.x - p.x;
              const dy = this.mouseInfluence.y - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < this.mouseInfluence.strength) {
                const force = (this.mouseInfluence.strength - dist) / this.mouseInfluence.strength;
                p.speedX += dx * force * 0.02;
                p.speedY += dy * force * 0.02;
                p.speedZ += Math.sin(Date.now() * 0.001) * force * 0.01; // Z方向にも影響
              }
            }
            
            // 速度の減衰
            p.speedX *= 0.95;
            p.speedY *= 0.95;
            p.speedZ *= 0.97; // Z方向はより緩やかに減衰
            
            // 位置の更新
            p.x += p.speedX;
            p.y += p.speedY;
            p.z += p.speedZ;
            
            // 画面外に出た場合の処理（3D空間）
            if (p.x < 0) p.x = this.width;
            if (p.x > this.width) p.x = 0;
            if (p.y < 0) p.y = this.height;
            if (p.y > this.height) p.y = 0;
            if (p.z < -100) p.z = 100;
            if (p.z > 100) p.z = -100;
          }
        }
        
        // 流体場の更新
        updateFlowField() {
          const time = Date.now() * 0.001;
          
          for (let i = 0; i < this.flowField.length; i++) {
            const field = this.flowField[i];
            // より複雑な時間変動パターン
            field.angle = (Math.sin(time * 0.1 + field.x * 0.01 + field.z * 0.005) + 
                         Math.cos(time * 0.15 + field.y * 0.01 - field.z * 0.003)) * Math.PI;
            field.strength = (Math.sin(time * 0.2 + field.x * 0.005 + field.y * 0.005 + field.z * 0.002) + 1) * 0.3 + 0.1;
            
            // Z座標も時間とともに変動
            field.z += Math.sin(time * 0.05 + i * 0.01) * 0.5;
            if (field.z < -100) field.z = 100;
            if (field.z > 100) field.z = -100;
          }
        }
        
        // 描画
        draw() {
          this.ctx.clearRect(0, 0, this.width, this.height);
          
          // パーティクルの描画（Z座標による大きさと透明度の変更）
          for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            
            // Z座標に基づく奥行き表現
            const scale = 1000 / (1000 + p.z * 2); // 奥行きに基づくスケーリング
            const size = p.size * scale * 3;
            const x = p.x;
            const y = p.y;
            const alpha = (p.z + 100) / 200 * 0.6 + 0.2; // Z座標に基づく透明度
            
            // 立体感のある描画
            this.ctx.beginPath();
            const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, p.color.replace('0.3', alpha.toFixed(2)));
            gradient.addColorStop(1, 'transparent');
            this.ctx.fillStyle = gradient;
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            
            // 光の効果（ハイライト）
            this.ctx.beginPath();
            const highlightSize = size * 0.3;
            const highlightGradient = this.ctx.createRadialGradient(
              x - size * 0.2, y - size * 0.2, 0,
              x - size * 0.2, y - size * 0.2, highlightSize
            );
            highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.8})`);
            highlightGradient.addColorStop(1, 'transparent');
            this.ctx.fillStyle = highlightGradient;
            this.ctx.arc(x - size * 0.2, y - size * 0.2, highlightSize, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // 3D空間内のパーティクル間の接続線
          this.ctx.strokeStyle = 'rgba(100, 150, 255, 0.05)';
          this.ctx.lineWidth = 0.5;
          
          for (let i = 0; i < this.particles.length; i++) {
            const p1 = this.particles[i];
            
            for (let j = i + 1; j < this.particles.length; j++) {
              const p2 = this.particles[j];
              const dx = p1.x - p2.x;
              const dy = p1.y - p2.y;
              const dz = p1.z - p2.z; // Z座標の差も考慮
              const dist = Math.sqrt(dx * dx + dy * dy);
              const dist3d = Math.sqrt(dx * dx + dy * dy + dz * dz); // 3D距離
              
              // 3D空間で近い場合のみ線を描画
              if (dist3d < 120) {
                const alpha = (1 - dist3d / 120) * 0.1;
                
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.lineTo(p2.x, p2.y);
                this.ctx.globalAlpha = alpha;
                this.ctx.stroke();
              }
            }
          }
          
          this.ctx.globalAlpha = 1;
        }
        
        // アニメーションループ
        animate() {
          this.updateFlowField();
          this.updateParticles();
          this.draw();
          
          requestAnimFrame(() => this.animate());
        }
      }
      
      // 量子波動効果の強化クラス
      class EnhancedQuantumWaveEffect extends QuantumWaveEffect {
        constructor(width, height) {
          super(width, height);
          this.zOffset = 0; // Z軸のオフセット（奥行き）
          this.mouseInfluence = { x: 0, y: 0, active: false };
          
          // マウス影響のイベントリスナー
          document.addEventListener('mousemove', this.handleMouseMove.bind(this));
        }
        
        handleMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          this.mouseInfluence.x = (e.clientX - rect.left) * (this.width / rect.width);
          this.mouseInfluence.y = (e.clientY - rect.top) * (this.height / rect.height);
        }
        
        // 波の高さを計算（3D効果を強化）
        getWaveHeight(x, y, time) {
          let height = 0;
          
          for (let i = 0; i < this.waves.length; i++) {
            const wave = this.waves[i];
            // より複雑な3Dのような波動パターン
            const angle = (x / wave.wavelength + y / (wave.wavelength * 2) + time * wave.speed + wave.phase);
            height += Math.sin(angle) * wave.amplitude;
            
            // Z軸の変動も追加
            this.zOffset = Math.sin(time * 0.2) * 50;
          }
          
          // マウス位置による波の歪み
          const dx = x - this.mouseInfluence.x;
          const dy = y - this.mouseInfluence.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 150) {
            height += (150 - dist) / 10 * Math.sin(time * 5);
          }
          
          return height;
        }
        
        // 描画メソッドのオーバーライド
        draw() {
          const time = Date.now() * 0.001;
          this.ctx.clearRect(0, 0, this.width, this.height);
          
          // より洗練されたグラデーション
          const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
          gradient.addColorStop(0, 'rgba(30, 64, 175, 0.08)');
          gradient.addColorStop(0.3, 'rgba(37, 99, 235, 0.1)');
          gradient.addColorStop(0.7, 'rgba(59, 130, 246, 0.08)');
          gradient.addColorStop(1, 'rgba(30, 58, 138, 0.06)');
          
          this.ctx.fillStyle = gradient;
          
          // 3D効果のある波の描画
          this.ctx.beginPath();
          this.ctx.moveTo(0, this.height / 2);
          
          // 波の密度を上げて滑らかに
          for (let x = 0; x < this.width; x += 3) {
            const y = this.height / 2 + this.getWaveHeight(x, 0, time);
            this.ctx.lineTo(x, y);
          }
          
          this.ctx.lineTo(this.width, this.height);
          this.ctx.lineTo(0, this.height);
          this.ctx.closePath();
          this.ctx.fill();
          
          // 複数の層による3D感の強化
          for (let layer = 1; layer <= 3; layer++) {
            const layerOffset = layer * 40;
            const alpha = 0.05 - layer * 0.01;
            
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            this.ctx.lineWidth = 1;
            
            // 各レイヤーの波線
            for (let y = 0; y < this.height; y += 40) {
              this.ctx.beginPath();
              
              for (let x = 0; x < this.width; x += 3) {
                const waveHeight = this.getWaveHeight(x, y + layerOffset, time + layer * 0.2) * 0.3;
                const yPos = y + waveHeight + this.zOffset / layer;
                
                if (x === 0) {
                  this.ctx.moveTo(x, yPos);
                } else {
                  this.ctx.lineTo(x, yPos);
                }
              }
              
              this.ctx.stroke();
            }
          }
        }
      }
      
      // 既存の3D空間歪み効果クラス
      // ... existing code ...
      
      // 効果の初期化
      function initEffects() {
        // ウィンドウサイズの取得
        const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        
        // 各効果の初期化
        setTimeout(() => {
          new FluidSimulation(width, height);
          new EnhancedQuantumWaveEffect(width, height);
          new SpaceDistortionEffect(width, height);
          
          // マウスパララックス効果の初期セットアップ
          setInterval(updateParallaxEffect, 1000/30); // 30fps更新
        }, 100);
      }
      
      // DOMContentLoadedイベントで初期化
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initEffects);
      } else {
        initEffects();
      }
    })();
  ]]></script>

  <foreignObject x="0" y="0" width="800" height="1500">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <!-- ウェルカム見出し -->
      <h1 class="flex-center">
        <img id="welcome-gif" width="28" height="28" alt="Welcome GIF" src="{{WELCOME_GIF_URL}}"/>
        <span style="margin-left:8px;">Welcome to my profile!</span>
      </h1>

      <!-- About Me -->
      <h2>👨‍💻 About Me</h2>
      <ul>
        <li>🧑‍💻 Full Stack Engineer with a passion for creating user-friendly applications</li>
        <li>🚀 Currently focusing on cloud-native architecture and microservices</li>
        <li>🔭 Working on building innovative services and solutions</li>
        <li>🌱 Learning more about AI/ML integration in web applications</li>
        <li>💡 Interested in open source contribution and community projects</li>
      </ul>

      <!-- Skills and Technologies -->
      <h2>🛠️ Skills and Technologies</h2>

      <h3>Frontend</h3>
      <p class="badge-row">
        <img id="react-img" alt="React" src="{{REACT_URL}}"/>
        <img id="nextjs-img" alt="Next.js" src="{{NEXTJS_URL}}"/>
        <img id="typescript-img" alt="TypeScript" src="{{TYPESCRIPT_URL}}"/>
        <img id="javascript-img" alt="JavaScript" src="{{JAVASCRIPT_URL}}"/>
        <img id="threejs-img" alt="Three.js" src="{{THREEJS_URL}}"/>
        <img id="tailwind-img" alt="Tailwind CSS" src="{{TAILWIND_URL}}"/>
        <img id="materialui-img" alt="Material UI" src="{{MATERIALUI_URL}}"/>
        <img id="astro-img" alt="Astro" src="{{ASTRO_URL}}"/>
      </p>

      <h3>Backend and Infrastructure</h3>
      <p class="badge-row">
        <img id="nodejs-img" alt="Node.js" src="{{NODEJS_URL}}"/>
        <img id="go-img" alt="Go" src="{{GO_URL}}"/>
        <img id="python-img" alt="Python" src="{{PYTHON_URL}}"/>
        <img id="csharp-img" alt="C#" src="{{CSHARP_URL}}"/>
        <img id="dotnet-img" alt=".NET" src="{{DOTNET_URL}}"/>
        <img id="docker-img" alt="Docker" src="{{DOCKER_URL}}"/>
        <img id="kubernetes-img" alt="Kubernetes" src="{{KUBERNETES_URL}}"/>
        <img id="graphql-img" alt="GraphQL" src="{{GRAPHQL_URL}}"/>
        <img id="postgresql-img" alt="PostgreSQL" src="{{POSTGRESQL_URL}}"/>
      </p>

      <!-- Cloud and DevOps -->
      <h3>Cloud and DevOps</h3>
      <p class="badge-row">
        <img id="aws-img" alt="AWS" src="{{AWS_URL}}"/>
        <img id="azure-img" alt="Azure" src="{{AZURE_URL}}"/>
        <img id="gcp-img" alt="GCP" src="{{GCP_URL}}"/>
        <img id="github-actions-img" alt="GitHub Actions" src="{{GITHUB_ACTIONS_URL}}"/>
        <img id="vercel-img" alt="Vercel" src="{{VERCEL_URL}}"/>
        <img id="firebase-img" alt="Firebase" src="{{FIREBASE_URL}}"/>
        <img id="supabase-img" alt="Supabase" src="{{SUPABASE_URL}}"/>
        <img id="cloudflare-img" alt="Cloudflare" src="{{CLOUDFLARE_URL}}"/>
      </p>

      <!-- Featured Projects -->
      <h2>📂 Featured Projects</h2>
      <p>Coming soon…</p>

      <!-- GitHub Stats -->
      <h2>📊 GitHub Stats</h2>
      <div class="center flex-center stats-section">
        <img id="github-stats-img" alt="GitHub Stats" class="stats-card" src="{{GITHUB_STATS_URL}}"/>
        <img id="top-langs-img" alt="Top Languages" class="stats-card" src="{{TOP_LANGUAGES_URL}}"/>
      </div>
      <div class="center stats-section">
        <img id="streak-stats-img" alt="GitHub Streak Stats" src="{{STREAK_STATS_URL}}"/>
      </div>

      <!-- Connect with Me -->
      <h2>📫 Connect with Me</h2>
      <div class="center">
        <a href="https://twitter.com/_aruday">
          <img id="twitter-img" alt="Twitter" src="{{TWITTER_URL}}"/>
        </a>
        <a href="https://github.com/yutosuda">
          <img id="github-img" alt="GitHub" src="{{GITHUB_URL}}"/>
        </a>
      </div>
    </body>
  </foreignObject>
</svg>